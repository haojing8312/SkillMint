# SkillMint 单端合并设计（Studio + Runtime）

## 1. 背景与目标

当前仓库包含两个客户端：
- `apps/studio`：Skill 打包端
- `apps/runtime`：Skill 使用端

本次设计目标：
- 合并为单一客户端应用（产品名称统一为 **SkillMint**）
- 将打包能力并入当前使用端
- 面向非技术用户优化命名和交互文案
- 无感迁移现有用户数据
- 保证原有功能不丢失

## 2. 设计原则

- 单端优先：用户只安装和使用一个客户端。
- 兼容优先：先做兼容映射，再做底层重构，避免回归。
- 文案优先：用户可见区域去技术术语。
- 渐进演进：分阶段交付，先并入，再清理。
- 可回滚：关键改动提供降级路径，不阻塞核心聊天能力。

## 3. 目标架构

### 3.1 应用层

保留一个客户端工程作为主应用（当前为 `apps/runtime`），并将其产品展示统一为 `SkillMint`。

### 3.2 功能模块

单端内统一为四个主模块：
- 对话
- 技能
- 打包
- 设置

### 3.3 打包能力合并

将 `apps/studio` 的能力迁入主应用：
- 前端组件：文件树、打包表单
- 后端命令：`read_skill_dir`、`pack_skill`
- 依赖能力：`skillpack-rs` 保持共享

## 4. 信息架构与体验重命名

### 4.1 顶层导航

- 对话：会话与聊天流
- 技能：安装、删除、导入、刷新
- 打包：目录选择、元信息编辑、导出 `.skillpack`
- 设置：模型、MCP、搜索、自动路由、操作确认级别

### 4.2 术语替换（用户可见）

以下仅针对展示层文案，底层值先兼容保留：
- `permission_mode` → `操作确认级别`
- `accept_edits` → `推荐模式`
- `default` → `谨慎模式`
- `unrestricted` → `全自动模式（高风险）`

约束：
- 产品中不出现 `runtime`、`studio`、`accept_edits`、`unrestricted` 等技术词。
- 错误提示改为用户可理解语言。

## 5. 无感迁移设计

### 5.1 数据与配置

- 沿用现有 runtime 数据目录和数据库位置。
- 不迁移、不重命名现有核心表结构（会话、模型、技能配置）。
- 新增能力（如打包历史）只做增量迁移，使用幂等 SQL。

### 5.2 兼容策略

- 旧权限值保持可读可写。
- 读取旧值时映射为新文案展示。
- 写入时可保持旧值格式，确保历史版本兼容和回滚安全。

### 5.3 启动行为

- 启动执行轻量迁移。
- 若新增模块迁移失败，仅降级新增模块，不阻断核心会话功能。

## 6. 功能不丢失保障

建立“功能对等矩阵”，逐项验收：
- 技能安装（含本地导入）
- 会话创建/删除/搜索/导出
- 聊天流式输出与工具展示
- 模型配置与连接测试
- MCP 服务器管理
- 搜索引擎配置
- 自动路由设置
- Skill 打包闭环（选择目录 → 打包 → 导出）

策略：
- 合并期间先并行保留旧能力，再删除旧模块。
- 删除 `apps/studio` 前必须通过全量回归。

## 7. 分阶段实施

### 阶段 A：并入能力

- 将 `studio` 的打包前后端能力并入主应用
- 新增“打包”入口与页面
- 验证打包主流程可用

### 阶段 B：体验重命名

- 全局替换用户可见术语
- 对敏感错误码做用户友好翻译
- 修正文案和帮助提示

### 阶段 C：迁移与回归

- 执行数据库增量迁移
- 完成兼容映射测试
- 执行“打包→安装→对话”端到端闭环

### 阶段 D：清理收口

- 删除 `apps/studio` 及其脚本引用
- 更新 README/架构图/开发文档
- 形成单端发布说明

## 8. 风险与缓解

- 风险：术语改名导致接口不兼容  
  缓解：只改展示层，保留底层枚举兼容。

- 风险：合并期间引入回归  
  缓解：功能对等矩阵 + 自动化回归 + 手工闭环验证。

- 风险：删除 `studio` 时遗漏依赖  
  缓解：先移除引用，再删目录，最后跑全仓构建和测试。

## 9. 验收标准

- 用户仅需一个客户端完成“打包 + 使用”。
- 历史会话、模型配置、已安装技能可直接使用。
- 用户可见区域无技术术语泄露。
- 功能对等矩阵全部通过。
- 文档完整更新为单端架构。

